{"version":3,"sources":["../../src/react/hooks.tsx","../../src/types/index.ts"],"sourcesContent":["import { useState, useEffect, useCallback, createContext, useContext, type ReactNode } from 'react';\nimport type { AuthState, UserInfo, TokenPayload } from '../types';\nimport { getUserId } from '../types';\n\nexport interface OIDCEndpoints {\n  authorization_endpoint: string;\n  token_endpoint: string;\n  userinfo_endpoint: string;\n  end_session_endpoint?: string;\n}\n\nexport interface NuPIdentityProviderConfig {\n  issuer: string;\n  clientId: string;\n  redirectUri?: string;\n  scopes?: string[];\n  endpoints?: Partial<OIDCEndpoints>;\n  onLoginSuccess?: (user: UserInfo) => void;\n  onLogoutSuccess?: () => void;\n  onError?: (error: Error) => void;\n}\n\ninterface NuPIdentityContextType extends AuthState {\n  login: () => void;\n  logout: () => Promise<void>;\n  getAccessToken: () => string | null;\n  getUserId: () => string | null;\n  refreshSession: () => Promise<boolean>;\n}\n\nconst NuPIdentityContext = createContext<NuPIdentityContextType | null>(null);\n\nconst TOKEN_STORAGE_KEY = 'nupidentity_access_token';\nconst REFRESH_TOKEN_KEY = 'nupidentity_refresh_token';\nconst ID_TOKEN_KEY = 'nupidentity_id_token';\n\nfunction parseJwt(token: string): TokenPayload | null {\n  try {\n    const base64Url = token.split('.')[1];\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join('')\n    );\n    return JSON.parse(jsonPayload);\n  } catch {\n    return null;\n  }\n}\n\nfunction isTokenExpired(token: string): boolean {\n  const payload = parseJwt(token);\n  if (!payload?.exp) return true;\n  return payload.exp * 1000 < Date.now();\n}\n\nfunction generateRandomString(length: number): string {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');\n}\n\nasync function sha256(message: string): Promise<ArrayBuffer> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  return crypto.subtle.digest('SHA-256', data);\n}\n\nfunction base64UrlEncode(buffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nconst DISCOVERY_CACHE_KEY = 'nupidentity_discovery';\nconst DISCOVERY_CACHE_TTL = 5 * 60 * 1000;\n\ninterface CachedDiscovery {\n  endpoints: OIDCEndpoints;\n  timestamp: number;\n}\n\nexport function NuPIdentityProvider({\n  children,\n  config,\n}: {\n  children: ReactNode;\n  config: NuPIdentityProviderConfig;\n}) {\n  const [state, setState] = useState<AuthState>({\n    isAuthenticated: false,\n    isLoading: true,\n    user: null,\n    error: null,\n  });\n\n  const [accessToken, setAccessToken] = useState<string | null>(null);\n  const [endpoints, setEndpoints] = useState<OIDCEndpoints | null>(null);\n\n  const getEndpoints = useCallback(async (): Promise<OIDCEndpoints> => {\n    if (config.endpoints?.authorization_endpoint && \n        config.endpoints?.token_endpoint && \n        config.endpoints?.userinfo_endpoint) {\n      return config.endpoints as OIDCEndpoints;\n    }\n\n    const cached = sessionStorage.getItem(DISCOVERY_CACHE_KEY);\n    if (cached) {\n      try {\n        const parsed: CachedDiscovery = JSON.parse(cached);\n        if (Date.now() - parsed.timestamp < DISCOVERY_CACHE_TTL) {\n          return parsed.endpoints;\n        }\n      } catch {}\n    }\n\n    try {\n      const response = await fetch(`${config.issuer}/.well-known/openid-configuration`);\n      if (!response.ok) {\n        throw new Error('Discovery failed');\n      }\n      const discovery = await response.json();\n      const discoveredEndpoints: OIDCEndpoints = {\n        authorization_endpoint: discovery.authorization_endpoint,\n        token_endpoint: discovery.token_endpoint,\n        userinfo_endpoint: discovery.userinfo_endpoint,\n        end_session_endpoint: discovery.end_session_endpoint,\n      };\n      \n      sessionStorage.setItem(DISCOVERY_CACHE_KEY, JSON.stringify({\n        endpoints: discoveredEndpoints,\n        timestamp: Date.now(),\n      }));\n      \n      return discoveredEndpoints;\n    } catch (error) {\n      console.warn('[NuPIdentity] Discovery failed, using default endpoints');\n      return {\n        authorization_endpoint: `${config.issuer}/api/oidc/authorize`,\n        token_endpoint: `${config.issuer}/api/oidc/token`,\n        userinfo_endpoint: `${config.issuer}/api/oidc/userinfo`,\n        end_session_endpoint: `${config.issuer}/api/oidc/logout`,\n      };\n    }\n  }, [config.issuer, config.endpoints]);\n\n  const fetchUserInfo = useCallback(async (token: string): Promise<UserInfo | null> => {\n    try {\n      const eps = await getEndpoints();\n      const response = await fetch(eps.userinfo_endpoint, {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch user info');\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('[NuPIdentity] Failed to fetch user info:', error);\n      return null;\n    }\n  }, [getEndpoints]);\n\n  const initializeSession = useCallback(async () => {\n    try {\n      const storedToken = sessionStorage.getItem(TOKEN_STORAGE_KEY);\n\n      if (storedToken && !isTokenExpired(storedToken)) {\n        const user = await fetchUserInfo(storedToken);\n\n        if (user) {\n          setAccessToken(storedToken);\n          setState({\n            isAuthenticated: true,\n            isLoading: false,\n            user,\n            error: null,\n          });\n          return;\n        }\n      }\n\n      sessionStorage.removeItem(TOKEN_STORAGE_KEY);\n      sessionStorage.removeItem(REFRESH_TOKEN_KEY);\n      sessionStorage.removeItem(ID_TOKEN_KEY);\n\n      setState({\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        error: null,\n      });\n    } catch (error) {\n      console.error('[NuPIdentity] Session initialization error:', error);\n      setState({\n        isAuthenticated: false,\n        isLoading: false,\n        user: null,\n        error: error as Error,\n      });\n    }\n  }, [fetchUserInfo]);\n\n  const handleCallback = useCallback(async () => {\n    const params = new URLSearchParams(window.location.search);\n    const code = params.get('code');\n    const returnedState = params.get('state');\n    const error = params.get('error');\n\n    const clearOAuthState = () => {\n      sessionStorage.removeItem('nupidentity_state');\n      sessionStorage.removeItem('nupidentity_code_verifier');\n      sessionStorage.removeItem('nupidentity_nonce');\n    };\n\n    if (error) {\n      const errorDesc = params.get('error_description') || error;\n      clearOAuthState();\n      config.onError?.(new Error(errorDesc));\n      return false;\n    }\n\n    if (!code || !returnedState) {\n      return false;\n    }\n\n    const storedState = sessionStorage.getItem('nupidentity_state');\n    const storedVerifier = sessionStorage.getItem('nupidentity_code_verifier');\n    const storedNonce = sessionStorage.getItem('nupidentity_nonce');\n\n    if (returnedState !== storedState) {\n      clearOAuthState();\n      config.onError?.(new Error('Invalid state parameter - possible CSRF attack'));\n      return false;\n    }\n\n    try {\n      const eps = await getEndpoints();\n      \n      const tokenResponse = await fetch(eps.token_endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: new URLSearchParams({\n          grant_type: 'authorization_code',\n          code,\n          client_id: config.clientId,\n          redirect_uri: config.redirectUri || window.location.origin + '/callback',\n          code_verifier: storedVerifier || '',\n        }),\n      });\n\n      if (!tokenResponse.ok) {\n        clearOAuthState();\n        throw new Error('Token exchange failed');\n      }\n\n      const tokens = await tokenResponse.json();\n\n      if (tokens.id_token && storedNonce) {\n        const idTokenPayload = parseJwt(tokens.id_token);\n        if (idTokenPayload && idTokenPayload.nonce !== storedNonce) {\n          clearOAuthState();\n          throw new Error('Invalid nonce in ID token - possible replay attack');\n        }\n      }\n\n      clearOAuthState();\n\n      sessionStorage.setItem(TOKEN_STORAGE_KEY, tokens.access_token);\n      if (tokens.refresh_token) {\n        sessionStorage.setItem(REFRESH_TOKEN_KEY, tokens.refresh_token);\n      }\n      if (tokens.id_token) {\n        sessionStorage.setItem(ID_TOKEN_KEY, tokens.id_token);\n      }\n\n      window.history.replaceState({}, document.title, window.location.pathname);\n\n      setAccessToken(tokens.access_token);\n\n      const user = await fetchUserInfo(tokens.access_token);\n      if (user) {\n        setState({\n          isAuthenticated: true,\n          isLoading: false,\n          user,\n          error: null,\n        });\n        config.onLoginSuccess?.(user);\n      }\n\n      return true;\n    } catch (error) {\n      console.error('[NuPIdentity] Callback handling error:', error);\n      clearOAuthState();\n      config.onError?.(error as Error);\n      return false;\n    }\n  }, [config, fetchUserInfo, getEndpoints]);\n\n  useEffect(() => {\n    const params = new URLSearchParams(window.location.search);\n    if (params.has('code') && params.has('state')) {\n      handleCallback();\n    } else {\n      initializeSession();\n    }\n  }, [handleCallback, initializeSession]);\n\n  const login = useCallback(async () => {\n    try {\n      const eps = await getEndpoints();\n      \n      const state = generateRandomString(32);\n      const nonce = generateRandomString(32);\n      const codeVerifier = generateRandomString(64);\n      const codeChallenge = base64UrlEncode(await sha256(codeVerifier));\n\n      sessionStorage.setItem('nupidentity_state', state);\n      sessionStorage.setItem('nupidentity_code_verifier', codeVerifier);\n      sessionStorage.setItem('nupidentity_nonce', nonce);\n\n      const scopes = config.scopes || ['openid', 'profile', 'email'];\n      const redirectUri = config.redirectUri || window.location.origin + '/callback';\n\n      const authUrl = new URL(eps.authorization_endpoint);\n      authUrl.searchParams.set('response_type', 'code');\n      authUrl.searchParams.set('client_id', config.clientId);\n      authUrl.searchParams.set('redirect_uri', redirectUri);\n      authUrl.searchParams.set('scope', scopes.join(' '));\n      authUrl.searchParams.set('state', state);\n      authUrl.searchParams.set('nonce', nonce);\n      authUrl.searchParams.set('code_challenge', codeChallenge);\n      authUrl.searchParams.set('code_challenge_method', 'S256');\n\n      window.location.href = authUrl.toString();\n    } catch (error) {\n      console.error('[NuPIdentity] Login error:', error);\n      config.onError?.(error as Error);\n    }\n  }, [config, getEndpoints]);\n\n  const logout = useCallback(async () => {\n    const idToken = sessionStorage.getItem(ID_TOKEN_KEY);\n\n    sessionStorage.removeItem(TOKEN_STORAGE_KEY);\n    sessionStorage.removeItem(REFRESH_TOKEN_KEY);\n    sessionStorage.removeItem(ID_TOKEN_KEY);\n\n    setAccessToken(null);\n    setState({\n      isAuthenticated: false,\n      isLoading: false,\n      user: null,\n      error: null,\n    });\n\n    config.onLogoutSuccess?.();\n\n    if (idToken) {\n      try {\n        const eps = await getEndpoints();\n        const logoutEndpoint = eps.end_session_endpoint || `${config.issuer}/api/oidc/logout`;\n        const logoutUrl = new URL(logoutEndpoint);\n        logoutUrl.searchParams.set('id_token_hint', idToken);\n        logoutUrl.searchParams.set('post_logout_redirect_uri', window.location.origin);\n        window.location.href = logoutUrl.toString();\n      } catch {\n        const logoutUrl = new URL(`${config.issuer}/api/oidc/logout`);\n        logoutUrl.searchParams.set('id_token_hint', idToken);\n        logoutUrl.searchParams.set('post_logout_redirect_uri', window.location.origin);\n        window.location.href = logoutUrl.toString();\n      }\n    }\n  }, [config, getEndpoints]);\n\n  const getAccessToken = useCallback(() => accessToken, [accessToken]);\n\n  const getUserIdFromToken = useCallback(() => {\n    if (!accessToken) return null;\n    const payload = parseJwt(accessToken);\n    return payload ? getUserId(payload) : null;\n  }, [accessToken]);\n\n  const refreshSession = useCallback(async (): Promise<boolean> => {\n    const refreshToken = sessionStorage.getItem(REFRESH_TOKEN_KEY);\n    if (!refreshToken) return false;\n\n    try {\n      const eps = await getEndpoints();\n      \n      const response = await fetch(eps.token_endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: new URLSearchParams({\n          grant_type: 'refresh_token',\n          refresh_token: refreshToken,\n          client_id: config.clientId,\n        }),\n      });\n\n      if (!response.ok) return false;\n\n      const tokens = await response.json();\n\n      sessionStorage.setItem(TOKEN_STORAGE_KEY, tokens.access_token);\n      if (tokens.refresh_token) {\n        sessionStorage.setItem(REFRESH_TOKEN_KEY, tokens.refresh_token);\n      }\n\n      setAccessToken(tokens.access_token);\n      return true;\n    } catch {\n      return false;\n    }\n  }, [config, getEndpoints]);\n\n  const contextValue: NuPIdentityContextType = {\n    ...state,\n    login,\n    logout,\n    getAccessToken,\n    getUserId: getUserIdFromToken,\n    refreshSession,\n  };\n\n  return (\n    <NuPIdentityContext.Provider value={contextValue}>\n      {children}\n    </NuPIdentityContext.Provider>\n  );\n}\n\nexport function useNuPIdentity(): NuPIdentityContextType {\n  const context = useContext(NuPIdentityContext);\n  if (!context) {\n    throw new Error('useNuPIdentity must be used within a NuPIdentityProvider');\n  }\n  return context;\n}\n\nexport function useUser(): UserInfo | null {\n  const { user } = useNuPIdentity();\n  return user;\n}\n\nexport function useIsAuthenticated(): boolean {\n  const { isAuthenticated } = useNuPIdentity();\n  return isAuthenticated;\n}\n\nexport function useAccessToken(): string | null {\n  const { getAccessToken } = useNuPIdentity();\n  return getAccessToken();\n}\n\nexport function usePermissions(): string[] {\n  const token = useAccessToken();\n  if (!token) return [];\n  \n  const payload = parseJwt(token);\n  return (payload as any)?.permissions ?? [];\n}\n\nexport function useHasPermission(permission: string): boolean {\n  const permissions = usePermissions();\n  return permissions.includes(permission);\n}\n\nexport function useHasAllPermissions(...requiredPermissions: string[]): boolean {\n  const permissions = usePermissions();\n  return requiredPermissions.every((perm) => permissions.includes(perm));\n}\n\nexport function useHasAnyPermission(...anyPermissions: string[]): boolean {\n  const permissions = usePermissions();\n  return anyPermissions.some((perm) => permissions.includes(perm));\n}\n\nexport { NuPIdentityContext };\n","export interface NuPIdentityConfig {\n  issuer: string;\n  clientId: string;\n  clientSecret?: string;\n  redirectUri?: string;\n  scopes?: string[];\n  audience?: string;\n}\n\nexport interface TokenPayload {\n  sub: string;\n  userId?: string;\n  id?: string;\n  email?: string;\n  name?: string;\n  organizationId?: string;\n  iat?: number;\n  exp?: number;\n  iss?: string;\n  aud?: string | string[];\n  nonce?: string;\n  scope?: string;\n  [key: string]: unknown;\n}\n\nexport interface OIDCDiscoveryDocument {\n  issuer: string;\n  authorization_endpoint: string;\n  token_endpoint: string;\n  userinfo_endpoint: string;\n  jwks_uri: string;\n  registration_endpoint?: string;\n  scopes_supported: string[];\n  response_types_supported: string[];\n  grant_types_supported: string[];\n  subject_types_supported: string[];\n  id_token_signing_alg_values_supported: string[];\n  claims_supported: string[];\n  end_session_endpoint?: string;\n}\n\nexport interface JWK {\n  kty: string;\n  use: string;\n  kid: string;\n  alg: string;\n  n?: string;\n  e?: string;\n}\n\nexport interface JWKS {\n  keys: JWK[];\n}\n\nexport interface TokenSet {\n  access_token: string;\n  token_type: string;\n  expires_in?: number;\n  refresh_token?: string;\n  id_token?: string;\n  scope?: string;\n}\n\nexport interface UserInfo {\n  sub: string;\n  email?: string;\n  email_verified?: boolean;\n  name?: string;\n  given_name?: string;\n  family_name?: string;\n  picture?: string;\n  organizationId?: string;\n  [key: string]: unknown;\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: UserInfo | null;\n  error: Error | null;\n}\n\nexport interface NuPIdentityError extends Error {\n  code: string;\n  statusCode?: number;\n}\n\nexport function getUserId(payload: TokenPayload): string {\n  return payload.userId ?? payload.id ?? payload.sub;\n}\n\nexport interface SystemFunction {\n  key: string;\n  name: string;\n  category?: string;\n  description?: string;\n  endpoint?: string;\n}\n\nexport interface SystemManifest {\n  system: {\n    id: string;\n    name: string;\n    description?: string;\n    version?: string;\n    apiUrl?: string;\n    callbackUrl?: string;\n  };\n  functions: SystemFunction[];\n}\n\nexport interface SystemRegistrationResult {\n  success: boolean;\n  message: string;\n  system: {\n    id: string;\n    name: string;\n    description?: string;\n    apiUrl?: string;\n    isActive?: boolean;\n    createdAt?: string;\n    updatedAt?: string;\n  };\n  functionsSync: {\n    total: number;\n    created: number;\n    updated: number;\n    removed: number;\n    removedList?: string[];\n  };\n  integration?: {\n    status: string;\n    nextSteps: string[];\n    endpoints?: Record<string, string>;\n    jwtSecretInstructions?: string;\n  };\n}\n\nexport interface UserSystemPermissions {\n  userId: string;\n  organizationId: string | null;\n  systemId: string;\n  systemName: string;\n  permissions: Array<{\n    functionId: string;\n    functionKey: string;\n    name: string;\n    category: string;\n    source: string;\n  }>;\n  functionKeys: string[];\n  total: number;\n}\n"],"mappings":"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","names":["error","state"]}