{"version":3,"sources":["../../src/express/index.ts","../../src/core/client.ts","../../src/types/index.ts","../../src/express/middleware.ts","../../src/express/setup.ts"],"sourcesContent":["export {\n  requireNuPAuth,\n  attachUser,\n  ensureScope,\n  ensureOrganization,\n  ensurePermission,\n  ensureAnyPermission,\n  createAuthRoutes,\n  NuPIdentityClient,\n} from './middleware';\n\nexport {\n  setupNuPIdentity,\n  defineManifest,\n  defineFunction,\n} from './setup';\n\nexport type { NuPIdentityMiddlewareOptions, AuthRoutesOptions } from './middleware';\nexport type { NuPIdentitySetupOptions, NuPIdentityApp } from './setup';\n","import * as crypto from 'crypto';\nimport type {\n  NuPIdentityConfig,\n  OIDCDiscoveryDocument,\n  JWKS,\n  JWK,\n  TokenSet,\n  UserInfo,\n  TokenPayload,\n  SystemManifest,\n  SystemRegistrationResult,\n  UserSystemPermissions,\n} from '../types';\n\nexport class NuPIdentityClient {\n  private config: NuPIdentityConfig;\n  private discoveryDocument: OIDCDiscoveryDocument | null = null;\n  private jwks: JWKS | null = null;\n  private jwksLastFetch: number = 0;\n  private readonly JWKS_CACHE_TTL = 5 * 60 * 1000;\n\n  constructor(config: NuPIdentityConfig) {\n    if (!config.issuer) {\n      throw new Error('[NuPIdentity] issuer is required');\n    }\n    if (!config.clientId) {\n      throw new Error('[NuPIdentity] clientId is required');\n    }\n\n    this.config = {\n      ...config,\n      issuer: config.issuer.replace(/\\/$/, ''),\n      scopes: config.scopes ?? ['openid', 'profile', 'email'],\n    };\n  }\n\n  async discover(retries = 2): Promise<OIDCDiscoveryDocument> {\n    if (this.discoveryDocument) {\n      return this.discoveryDocument;\n    }\n\n    const url = `${this.config.issuer}/.well-known/openid-configuration`;\n    let lastError: Error | null = null;\n    \n    for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeout = setTimeout(() => controller.abort(), 5000);\n        \n        const response = await fetch(url, { signal: controller.signal });\n        clearTimeout(timeout);\n        \n        if (!response.ok) {\n          throw new Error(`Discovery failed: ${response.status} ${response.statusText}`);\n        }\n        \n        this.discoveryDocument = await response.json() as OIDCDiscoveryDocument;\n        console.log('[NuPIdentity] Discovery document loaded successfully');\n        return this.discoveryDocument;\n      } catch (error) {\n        lastError = error as Error;\n        console.error(`[NuPIdentity] Discovery attempt ${attempt} failed:`, error);\n        if (attempt < retries) {\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      }\n    }\n    \n    throw new Error(`[NuPIdentity] Failed to discover OIDC configuration: ${lastError?.message}`);\n  }\n\n  async getJWKS(): Promise<JWKS> {\n    const now = Date.now();\n    \n    if (this.jwks && (now - this.jwksLastFetch) < this.JWKS_CACHE_TTL) {\n      return this.jwks;\n    }\n\n    const discovery = await this.discover();\n    \n    try {\n      const response = await fetch(discovery.jwks_uri);\n      if (!response.ok) {\n        throw new Error(`JWKS fetch failed: ${response.status}`);\n      }\n      \n      this.jwks = await response.json() as JWKS;\n      this.jwksLastFetch = now;\n      console.log('[NuPIdentity] JWKS loaded successfully');\n      return this.jwks;\n    } catch (error) {\n      console.error('[NuPIdentity] Failed to fetch JWKS:', error);\n      throw new Error(`[NuPIdentity] Failed to fetch JWKS: ${error}`);\n    }\n  }\n\n  private async getPublicKey(kid: string): Promise<crypto.KeyObject> {\n    const jwks = await this.getJWKS();\n    const jwk = jwks.keys.find((k) => k.kid === kid);\n\n    if (!jwk) {\n      this.jwks = null;\n      const refreshedJwks = await this.getJWKS();\n      const refreshedJwk = refreshedJwks.keys.find((k) => k.kid === kid);\n      \n      if (!refreshedJwk) {\n        throw new Error(`[NuPIdentity] Key with kid \"${kid}\" not found in JWKS`);\n      }\n      \n      return crypto.createPublicKey({ key: refreshedJwk as unknown as crypto.JsonWebKey, format: 'jwk' });\n    }\n\n    return crypto.createPublicKey({ key: jwk as unknown as crypto.JsonWebKey, format: 'jwk' });\n  }\n\n  async verifyToken(token: string): Promise<TokenPayload> {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new Error('[NuPIdentity] Invalid token format');\n    }\n\n    const [headerB64, payloadB64, signatureB64] = parts;\n\n    const header = JSON.parse(Buffer.from(headerB64, 'base64url').toString());\n    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString()) as TokenPayload;\n\n    if (header.alg !== 'RS256') {\n      throw new Error(`[NuPIdentity] Unsupported algorithm: ${header.alg}`);\n    }\n\n    const publicKey = await this.getPublicKey(header.kid);\n\n    const signatureInput = `${headerB64}.${payloadB64}`;\n    const signature = Buffer.from(signatureB64, 'base64url');\n\n    const isValid = crypto.verify(\n      'RSA-SHA256',\n      Buffer.from(signatureInput),\n      publicKey,\n      signature\n    );\n\n    if (!isValid) {\n      throw new Error('[NuPIdentity] Invalid token signature');\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n\n    if (payload.exp && payload.exp < now) {\n      throw new Error('[NuPIdentity] Token has expired');\n    }\n\n    if (payload.iss && payload.iss !== this.config.issuer) {\n      throw new Error(`[NuPIdentity] Invalid issuer: expected ${this.config.issuer}, got ${payload.iss}`);\n    }\n\n    return payload;\n  }\n\n  getAuthorizationUrl(options?: {\n    state?: string;\n    nonce?: string;\n    redirectUri?: string;\n    scopes?: string[];\n    codeChallenge?: string;\n    codeChallengeMethod?: 'S256' | 'plain';\n  }): string {\n    const discovery = this.discoveryDocument;\n    if (!discovery) {\n      throw new Error('[NuPIdentity] Call discover() first');\n    }\n\n    const params = new URLSearchParams({\n      response_type: 'code',\n      client_id: this.config.clientId,\n      redirect_uri: options?.redirectUri ?? this.config.redirectUri ?? '',\n      scope: (options?.scopes ?? this.config.scopes ?? ['openid']).join(' '),\n    });\n\n    if (options?.state) params.set('state', options.state);\n    if (options?.nonce) params.set('nonce', options.nonce);\n    if (options?.codeChallenge) {\n      params.set('code_challenge', options.codeChallenge);\n      params.set('code_challenge_method', options.codeChallengeMethod ?? 'S256');\n    }\n    if (this.config.audience) {\n      params.set('audience', this.config.audience);\n    }\n\n    return `${discovery.authorization_endpoint}?${params.toString()}`;\n  }\n\n  async exchangeCode(\n    code: string,\n    redirectUri?: string,\n    codeVerifier?: string\n  ): Promise<TokenSet> {\n    const discovery = await this.discover();\n\n    const body = new URLSearchParams({\n      grant_type: 'authorization_code',\n      code,\n      client_id: this.config.clientId,\n      redirect_uri: redirectUri ?? this.config.redirectUri ?? '',\n    });\n\n    if (this.config.clientSecret) {\n      body.set('client_secret', this.config.clientSecret);\n    }\n\n    if (codeVerifier) {\n      body.set('code_verifier', codeVerifier);\n    }\n\n    const response = await fetch(discovery.token_endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: body.toString(),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`[NuPIdentity] Token exchange failed: ${error}`);\n    }\n\n    return response.json() as Promise<TokenSet>;\n  }\n\n  async getUserInfo(accessToken: string): Promise<UserInfo> {\n    const discovery = await this.discover();\n\n    const response = await fetch(discovery.userinfo_endpoint, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`[NuPIdentity] UserInfo request failed: ${response.status}`);\n    }\n\n    return response.json() as Promise<UserInfo>;\n  }\n\n  async refreshToken(refreshToken: string): Promise<TokenSet> {\n    const discovery = await this.discover();\n\n    const body = new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: refreshToken,\n      client_id: this.config.clientId,\n    });\n\n    if (this.config.clientSecret) {\n      body.set('client_secret', this.config.clientSecret);\n    }\n\n    const response = await fetch(discovery.token_endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: body.toString(),\n    });\n\n    if (!response.ok) {\n      throw new Error('[NuPIdentity] Token refresh failed');\n    }\n\n    return response.json() as Promise<TokenSet>;\n  }\n\n  getLogoutUrl(options?: { idTokenHint?: string; postLogoutRedirectUri?: string }): string {\n    const discovery = this.discoveryDocument;\n    if (!discovery?.end_session_endpoint) {\n      throw new Error('[NuPIdentity] Logout endpoint not available');\n    }\n\n    const params = new URLSearchParams();\n    \n    if (options?.idTokenHint) {\n      params.set('id_token_hint', options.idTokenHint);\n    }\n    if (options?.postLogoutRedirectUri) {\n      params.set('post_logout_redirect_uri', options.postLogoutRedirectUri);\n    }\n\n    const queryString = params.toString();\n    return queryString \n      ? `${discovery.end_session_endpoint}?${queryString}` \n      : discovery.end_session_endpoint;\n  }\n\n  async registerSystem(\n    manifest: SystemManifest,\n    apiKey: string\n  ): Promise<SystemRegistrationResult> {\n    const url = `${this.config.issuer}/api/systems/register`;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-System-API-Key': apiKey,\n      },\n      body: JSON.stringify(manifest),\n    });\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({ message: 'Unknown error' }));\n      throw new Error(`[NuPIdentity] System registration failed: ${error.message || error.error}`);\n    }\n\n    const result = await response.json() as SystemRegistrationResult;\n    console.log(`[NuPIdentity] System registered: ${manifest.system.id} - ${result.functionsSync.created} created, ${result.functionsSync.updated} updated`);\n    return result;\n  }\n\n  async syncFunctions(\n    systemId: string,\n    manifest: SystemManifest,\n    accessToken: string\n  ): Promise<SystemRegistrationResult> {\n    const url = `${this.config.issuer}/api/systems/${systemId}/sync-functions`;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(manifest),\n    });\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({ message: 'Unknown error' }));\n      throw new Error(`[NuPIdentity] Function sync failed: ${error.message || error.error}`);\n    }\n\n    return response.json() as Promise<SystemRegistrationResult>;\n  }\n\n  async getUserPermissions(\n    userId: string,\n    systemId: string,\n    accessToken: string\n  ): Promise<UserSystemPermissions> {\n    const url = `${this.config.issuer}/api/validate/users/${userId}/systems/${systemId}/permissions`;\n\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`[NuPIdentity] Failed to get user permissions: ${response.status}`);\n    }\n\n    return response.json() as Promise<UserSystemPermissions>;\n  }\n\n  static generateCodeVerifier(): string {\n    return crypto.randomBytes(32).toString('base64url');\n  }\n\n  static generateCodeChallenge(verifier: string): string {\n    return crypto.createHash('sha256').update(verifier).digest('base64url');\n  }\n\n  static generateState(): string {\n    return crypto.randomBytes(16).toString('base64url');\n  }\n\n  static generateNonce(): string {\n    return crypto.randomBytes(16).toString('base64url');\n  }\n}\n","export interface NuPIdentityConfig {\n  issuer: string;\n  clientId: string;\n  clientSecret?: string;\n  redirectUri?: string;\n  scopes?: string[];\n  audience?: string;\n}\n\nexport interface TokenPayload {\n  sub: string;\n  userId?: string;\n  id?: string;\n  email?: string;\n  name?: string;\n  organizationId?: string;\n  iat?: number;\n  exp?: number;\n  iss?: string;\n  aud?: string | string[];\n  nonce?: string;\n  scope?: string;\n  [key: string]: unknown;\n}\n\nexport interface OIDCDiscoveryDocument {\n  issuer: string;\n  authorization_endpoint: string;\n  token_endpoint: string;\n  userinfo_endpoint: string;\n  jwks_uri: string;\n  registration_endpoint?: string;\n  scopes_supported: string[];\n  response_types_supported: string[];\n  grant_types_supported: string[];\n  subject_types_supported: string[];\n  id_token_signing_alg_values_supported: string[];\n  claims_supported: string[];\n  end_session_endpoint?: string;\n}\n\nexport interface JWK {\n  kty: string;\n  use: string;\n  kid: string;\n  alg: string;\n  n?: string;\n  e?: string;\n}\n\nexport interface JWKS {\n  keys: JWK[];\n}\n\nexport interface TokenSet {\n  access_token: string;\n  token_type: string;\n  expires_in?: number;\n  refresh_token?: string;\n  id_token?: string;\n  scope?: string;\n}\n\nexport interface UserInfo {\n  sub: string;\n  email?: string;\n  email_verified?: boolean;\n  name?: string;\n  given_name?: string;\n  family_name?: string;\n  picture?: string;\n  organizationId?: string;\n  [key: string]: unknown;\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: UserInfo | null;\n  error: Error | null;\n}\n\nexport interface NuPIdentityError extends Error {\n  code: string;\n  statusCode?: number;\n}\n\nexport function getUserId(payload: TokenPayload): string {\n  return payload.userId ?? payload.id ?? payload.sub;\n}\n\nexport interface SystemFunction {\n  key: string;\n  name: string;\n  category?: string;\n  description?: string;\n  endpoint?: string;\n}\n\nexport interface SystemManifest {\n  system: {\n    id: string;\n    name: string;\n    description?: string;\n    version?: string;\n    apiUrl?: string;\n    callbackUrl?: string;\n  };\n  functions: SystemFunction[];\n}\n\nexport interface SystemRegistrationResult {\n  success: boolean;\n  message: string;\n  system: {\n    id: string;\n    name: string;\n    description?: string;\n    apiUrl?: string;\n    isActive?: boolean;\n    createdAt?: string;\n    updatedAt?: string;\n  };\n  functionsSync: {\n    total: number;\n    created: number;\n    updated: number;\n    removed: number;\n    removedList?: string[];\n  };\n  integration?: {\n    status: string;\n    nextSteps: string[];\n    endpoints?: Record<string, string>;\n    jwtSecretInstructions?: string;\n  };\n}\n\nexport interface UserSystemPermissions {\n  userId: string;\n  organizationId: string | null;\n  systemId: string;\n  systemName: string;\n  permissions: Array<{\n    functionId: string;\n    functionKey: string;\n    name: string;\n    category: string;\n    source: string;\n  }>;\n  functionKeys: string[];\n  total: number;\n}\n","import type { Request, Response, NextFunction, RequestHandler } from 'express';\nimport { NuPIdentityClient } from '../core/client';\nimport type { NuPIdentityConfig, TokenPayload, UserInfo } from '../types';\nimport { getUserId } from '../types';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: TokenPayload;\n      userId?: string;\n      accessToken?: string;\n    }\n  }\n}\n\nexport interface NuPIdentityMiddlewareOptions extends NuPIdentityConfig {\n  tokenExtractor?: (req: Request) => string | null;\n  onError?: (error: Error, req: Request, res: Response) => void;\n  optional?: boolean;\n}\n\nconst clientCache = new Map<string, { client: NuPIdentityClient; initPromise: Promise<void> }>();\n\nfunction getCacheKey(config: NuPIdentityConfig): string {\n  return `${config.issuer}:${config.clientId}`;\n}\n\nasync function initializeClient(config: NuPIdentityConfig): Promise<NuPIdentityClient> {\n  const cacheKey = getCacheKey(config);\n  \n  let cached = clientCache.get(cacheKey);\n  \n  if (!cached) {\n    const client = new NuPIdentityClient(config);\n    const initPromise = client.discover().then(() => {\n      console.log(`[NuPIdentity] Client initialized for ${config.issuer}`);\n    }).catch((error) => {\n      console.error('[NuPIdentity] Client initialization failed:', error);\n      clientCache.delete(cacheKey);\n      throw error;\n    });\n    \n    cached = { client, initPromise };\n    clientCache.set(cacheKey, cached);\n  }\n  \n  await cached.initPromise;\n  return cached.client;\n}\n\nfunction defaultTokenExtractor(req: Request): string | null {\n  const authHeader = req.headers.authorization;\n  if (authHeader?.startsWith('Bearer ')) {\n    return authHeader.slice(7);\n  }\n\n  if (req.cookies?.access_token) {\n    return req.cookies.access_token;\n  }\n\n  if (req.query?.access_token && typeof req.query.access_token === 'string') {\n    return req.query.access_token;\n  }\n\n  return null;\n}\n\nfunction defaultErrorHandler(error: Error, req: Request, res: Response): void {\n  console.error('[NuPIdentity] Authentication error:', error.message);\n  res.status(401).json({\n    error: 'Unauthorized',\n    message: error.message,\n  });\n}\n\nexport function requireNuPAuth(options: NuPIdentityMiddlewareOptions): RequestHandler {\n  const tokenExtractor = options.tokenExtractor ?? defaultTokenExtractor;\n  const onError = options.onError ?? defaultErrorHandler;\n\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const token = tokenExtractor(req);\n\n      if (!token) {\n        if (options.optional) {\n          return next();\n        }\n        throw new Error('No access token provided');\n      }\n\n      const client = await initializeClient(options);\n      const payload = await client.verifyToken(token);\n\n      req.user = payload;\n      req.userId = getUserId(payload);\n      req.accessToken = token;\n\n      next();\n    } catch (error) {\n      if (options.optional) {\n        return next();\n      }\n      onError(error as Error, req, res);\n    }\n  };\n}\n\nexport function attachUser(options: NuPIdentityMiddlewareOptions): RequestHandler {\n  return requireNuPAuth({ ...options, optional: true });\n}\n\nexport function ensureScope(...requiredScopes: string[]): RequestHandler {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized', message: 'No user attached' });\n      return;\n    }\n\n    const tokenScopes = req.user.scope?.split(' ') ?? [];\n    const hasAllScopes = requiredScopes.every((scope) => tokenScopes.includes(scope));\n\n    if (!hasAllScopes) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: `Missing required scopes: ${requiredScopes.join(', ')}`,\n      });\n      return;\n    }\n\n    next();\n  };\n}\n\nexport function ensureOrganization(organizationId?: string): RequestHandler {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({ error: 'Unauthorized', message: 'No user attached' });\n      return;\n    }\n\n    const userOrgId = req.user.organizationId;\n\n    if (!userOrgId) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: 'User does not belong to any organization',\n      });\n      return;\n    }\n\n    if (organizationId && userOrgId !== organizationId) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: 'User does not belong to the required organization',\n      });\n      return;\n    }\n\n    next();\n  };\n}\n\nexport function ensurePermission(\n  options: NuPIdentityMiddlewareOptions,\n  ...requiredPermissions: string[]\n): RequestHandler[] {\n  const authMiddleware = requireNuPAuth({ ...options, optional: false });\n  \n  const permissionMiddleware: RequestHandler = (req: Request, res: Response, next: NextFunction): void => {\n    const userPermissions = (req.user as any)?.permissions as string[] | undefined;\n    \n    if (!userPermissions || userPermissions.length === 0) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: 'No permissions found in token',\n        required: requiredPermissions,\n      });\n      return;\n    }\n\n    const hasAllPermissions = requiredPermissions.every((perm) => \n      userPermissions.includes(perm)\n    );\n\n    if (!hasAllPermissions) {\n      const missing = requiredPermissions.filter((perm) => !userPermissions.includes(perm));\n      res.status(403).json({\n        error: 'Forbidden',\n        message: `Missing required permissions: ${missing.join(', ')}`,\n        required: requiredPermissions,\n        missing,\n      });\n      return;\n    }\n\n    next();\n  };\n\n  return [authMiddleware, permissionMiddleware];\n}\n\nexport function ensureAnyPermission(\n  options: NuPIdentityMiddlewareOptions,\n  ...anyPermissions: string[]\n): RequestHandler[] {\n  const authMiddleware = requireNuPAuth({ ...options, optional: false });\n  \n  const permissionMiddleware: RequestHandler = (req: Request, res: Response, next: NextFunction): void => {\n    const userPermissions = (req.user as any)?.permissions as string[] | undefined;\n    \n    if (!userPermissions || userPermissions.length === 0) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: 'No permissions found in token',\n        required: anyPermissions,\n      });\n      return;\n    }\n\n    const hasAnyPermission = anyPermissions.some((perm) => \n      userPermissions.includes(perm)\n    );\n\n    if (!hasAnyPermission) {\n      res.status(403).json({\n        error: 'Forbidden',\n        message: `Requires at least one of: ${anyPermissions.join(', ')}`,\n        required: anyPermissions,\n      });\n      return;\n    }\n\n    next();\n  };\n\n  return [authMiddleware, permissionMiddleware];\n}\n\nexport interface AuthRoutesOptions extends NuPIdentityMiddlewareOptions {\n  successRedirect?: string;\n  failureRedirect?: string;\n}\n\nexport async function createAuthRoutes(options: AuthRoutesOptions, expressApp: { Router: () => any }) {\n  const cookieParserModule = await import('cookie-parser');\n  const cookieParser = cookieParserModule.default || cookieParserModule;\n  const router = expressApp.Router();\n  \n  router.use(cookieParser());\n  \n  const OAUTH_STATE_COOKIE = 'nupidentity_oauth_state';\n  const OAUTH_VERIFIER_COOKIE = 'nupidentity_code_verifier';\n  const OAUTH_NONCE_COOKIE = 'nupidentity_nonce';\n  \n  // In Replit and cloud environments, we're always behind HTTPS\n  const isSecure = process.env.NODE_ENV === 'production' || \n                   !!process.env.REPL_ID || \n                   !!process.env.REPLIT_DEV_DOMAIN ||\n                   (process.env.APP_URL?.startsWith('https://') ?? false);\n  \n  const cookieOptions = {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: 'lax' as const,\n    maxAge: 10 * 60 * 1000,\n    path: '/',\n  };\n\n  router.get('/login', async (req: Request, res: Response) => {\n    try {\n      const client = await initializeClient(options);\n\n      const state = NuPIdentityClient.generateState();\n      const nonce = NuPIdentityClient.generateNonce();\n      const codeVerifier = NuPIdentityClient.generateCodeVerifier();\n      const codeChallenge = NuPIdentityClient.generateCodeChallenge(codeVerifier);\n\n      res.cookie(OAUTH_STATE_COOKIE, state, cookieOptions);\n      res.cookie(OAUTH_VERIFIER_COOKIE, codeVerifier, cookieOptions);\n      res.cookie(OAUTH_NONCE_COOKIE, nonce, cookieOptions);\n\n      const authUrl = client.getAuthorizationUrl({\n        state,\n        nonce,\n        codeChallenge,\n        codeChallengeMethod: 'S256',\n        redirectUri: options.redirectUri,\n      });\n\n      res.redirect(authUrl);\n    } catch (error) {\n      console.error('[NuPIdentity] Login error:', error);\n      if (options.failureRedirect) {\n        res.redirect(options.failureRedirect + '?error=login_failed');\n      } else {\n        res.status(500).json({ error: 'Failed to initiate login' });\n      }\n    }\n  });\n\n  router.get('/callback', async (req: Request, res: Response) => {\n    const clearOAuthCookies = () => {\n      res.clearCookie(OAUTH_STATE_COOKIE);\n      res.clearCookie(OAUTH_VERIFIER_COOKIE);\n      res.clearCookie(OAUTH_NONCE_COOKIE);\n    };\n    \n    try {\n      const { code, state, error, error_description } = req.query;\n\n      if (error) {\n        clearOAuthCookies();\n        throw new Error(`OAuth error: ${error} - ${error_description}`);\n      }\n\n      if (!code || !state || typeof code !== 'string' || typeof state !== 'string') {\n        clearOAuthCookies();\n        throw new Error('Missing code or state parameter');\n      }\n\n      const storedState = req.cookies?.[OAUTH_STATE_COOKIE];\n      const storedVerifier = req.cookies?.[OAUTH_VERIFIER_COOKIE];\n      const storedNonce = req.cookies?.[OAUTH_NONCE_COOKIE];\n      \n      if (!storedState || !storedVerifier) {\n        clearOAuthCookies();\n        throw new Error('Missing OAuth state cookies - session may have expired');\n      }\n      \n      if (state !== storedState) {\n        clearOAuthCookies();\n        throw new Error('Invalid state parameter - possible CSRF attack');\n      }\n\n      clearOAuthCookies();\n\n      const client = await initializeClient(options);\n      const tokens = await client.exchangeCode(\n        code,\n        options.redirectUri,\n        storedVerifier\n      );\n\n      if (tokens.id_token && storedNonce) {\n        try {\n          const idTokenPayload = JSON.parse(\n            Buffer.from(tokens.id_token.split('.')[1], 'base64url').toString()\n          );\n          if (idTokenPayload.nonce !== storedNonce) {\n            throw new Error('Invalid nonce in ID token - possible replay attack');\n          }\n        } catch (nonceError) {\n          if ((nonceError as Error).message.includes('nonce')) {\n            throw nonceError;\n          }\n          console.warn('[NuPIdentity] Could not validate nonce:', nonceError);\n        }\n      }\n\n      res.cookie('access_token', tokens.access_token, {\n        httpOnly: true,\n        secure: isSecure,\n        sameSite: 'lax',\n        maxAge: (tokens.expires_in ?? 3600) * 1000,\n      });\n\n      if (tokens.refresh_token) {\n        res.cookie('refresh_token', tokens.refresh_token, {\n          httpOnly: true,\n          secure: isSecure,\n          sameSite: 'lax',\n          maxAge: 7 * 24 * 60 * 60 * 1000,\n        });\n      }\n      \n      if (tokens.id_token) {\n        res.cookie('id_token', tokens.id_token, {\n          httpOnly: true,\n          secure: isSecure,\n          sameSite: 'lax',\n          maxAge: (tokens.expires_in ?? 3600) * 1000,\n        });\n      }\n\n      res.redirect(options.successRedirect ?? '/');\n    } catch (error) {\n      console.error('[NuPIdentity] Callback error:', error);\n      if (options.failureRedirect) {\n        const errorMsg = encodeURIComponent((error as Error).message);\n        res.redirect(`${options.failureRedirect}?error=${errorMsg}`);\n      } else {\n        res.status(500).json({ error: 'Authentication failed', message: (error as Error).message });\n      }\n    }\n  });\n\n  router.get('/me', requireNuPAuth(options), async (req: Request, res: Response) => {\n    try {\n      if (!req.accessToken) {\n        throw new Error('No access token');\n      }\n\n      const client = await initializeClient(options);\n      const userInfo = await client.getUserInfo(req.accessToken);\n\n      res.json(userInfo);\n    } catch (error) {\n      res.status(500).json({ error: 'Failed to get user info' });\n    }\n  });\n\n  router.post('/logout', (req: Request, res: Response) => {\n    res.clearCookie('access_token');\n    res.clearCookie('refresh_token');\n    res.json({ success: true });\n  });\n\n  router.post('/refresh', async (req: Request, res: Response) => {\n    try {\n      const refreshToken = req.cookies?.refresh_token;\n      if (!refreshToken) {\n        throw new Error('No refresh token');\n      }\n\n      const client = await initializeClient(options);\n      const tokens = await client.refreshToken(refreshToken);\n\n      res.cookie('access_token', tokens.access_token, {\n        httpOnly: true,\n        secure: isSecure,\n        sameSite: 'lax',\n        maxAge: (tokens.expires_in ?? 3600) * 1000,\n      });\n\n      res.json({ success: true, expires_in: tokens.expires_in });\n    } catch (error) {\n      res.status(401).json({ error: 'Token refresh failed' });\n    }\n  });\n\n  return router;\n}\n\nexport { NuPIdentityClient };\n","import type { Express } from 'express';\nimport { NuPIdentityClient } from '../core/client';\nimport type { SystemManifest, SystemRegistrationResult, NuPIdentityConfig } from '../types';\nimport { createAuthRoutes, requireNuPAuth, ensurePermission, ensureAnyPermission, type AuthRoutesOptions } from './middleware';\n\nexport interface NuPIdentitySetupOptions extends NuPIdentityConfig {\n  systemApiKey: string;\n  manifest: SystemManifest;\n  authRoutePrefix?: string;\n  successRedirect?: string;\n  failureRedirect?: string;\n  syncOnStartup?: boolean;\n  failOnSyncError?: boolean;\n  onRegistrationComplete?: (result: SystemRegistrationResult) => void;\n  onRegistrationError?: (error: Error) => void;\n}\n\nexport interface NuPIdentityApp {\n  client: NuPIdentityClient;\n  config: NuPIdentityConfig;\n  manifest: SystemManifest;\n  isRegistered: boolean;\n  getRegistrationResult: () => SystemRegistrationResult | null;\n  requireAuth: ReturnType<typeof requireNuPAuth>;\n  ensurePermission: (...permissions: string[]) => ReturnType<typeof ensurePermission>;\n  ensureAnyPermission: (...permissions: string[]) => ReturnType<typeof ensureAnyPermission>;\n  syncFunctions: () => Promise<SystemRegistrationResult>;\n}\n\nexport async function setupNuPIdentity(\n  app: Express,\n  options: NuPIdentitySetupOptions\n): Promise<NuPIdentityApp> {\n  const {\n    manifest,\n    systemApiKey,\n    authRoutePrefix = '/auth',\n    successRedirect = '/',\n    failureRedirect = '/login',\n    syncOnStartup = true,\n    failOnSyncError = false,\n    onRegistrationComplete,\n    onRegistrationError,\n    ...clientConfig\n  } = options;\n\n  const client = new NuPIdentityClient(clientConfig);\n  let registrationResult: SystemRegistrationResult | null = null;\n\n  console.log(`[NuPIdentity] Initializing integration for system: ${manifest.system.id}`);\n\n  await client.discover();\n  console.log(`[NuPIdentity] Connected to ${clientConfig.issuer}`);\n\n  const expressModule = await import('express');\n  const authRoutes = await createAuthRoutes({\n    ...clientConfig,\n    successRedirect,\n    failureRedirect,\n  } as AuthRoutesOptions, expressModule.default || expressModule);\n  \n  app.use(authRoutePrefix, authRoutes);\n  console.log(`[NuPIdentity] Auth routes mounted at ${authRoutePrefix}`);\n\n  const syncFunctions = async (): Promise<SystemRegistrationResult> => {\n    try {\n      console.log(`[NuPIdentity] Syncing ${manifest.functions.length} functions for ${manifest.system.id}...`);\n      \n      const result = await client.registerSystem(manifest, systemApiKey);\n      registrationResult = result;\n      \n      console.log(`[NuPIdentity] Sync complete:`);\n      console.log(`  - System: ${result.system.name} (${result.system.id})`);\n      console.log(`  - Functions: ${result.functionsSync.created} created, ${result.functionsSync.updated} updated, ${result.functionsSync.removed} removed`);\n      \n      if (result.integration?.nextSteps?.length) {\n        console.log(`[NuPIdentity] Next steps:`);\n        result.integration.nextSteps.forEach((step, i) => {\n          console.log(`  ${i + 1}. ${step}`);\n        });\n      }\n      \n      onRegistrationComplete?.(result);\n      return result;\n    } catch (error) {\n      console.error(`[NuPIdentity] Sync failed:`, error);\n      onRegistrationError?.(error as Error);\n      throw error;\n    }\n  };\n\n  if (syncOnStartup) {\n    try {\n      await syncFunctions();\n    } catch (error) {\n      if (failOnSyncError) {\n        throw new Error(`[NuPIdentity] System registration failed: ${(error as Error).message}`);\n      }\n      console.warn(`[NuPIdentity] Initial sync failed, continuing without registration. Reason: ${(error as Error).message}`);\n      console.warn(`[NuPIdentity] Set failOnSyncError: true to make this error fatal.`);\n    }\n  }\n\n  const systemId = manifest.system.id;\n  \n  const nuPIdentityApp: NuPIdentityApp = {\n    client,\n    config: clientConfig,\n    manifest,\n    \n    get isRegistered() {\n      return registrationResult !== null;\n    },\n    \n    getRegistrationResult: () => registrationResult,\n    \n    requireAuth: requireNuPAuth(clientConfig),\n    \n    ensurePermission: (...permissions: string[]) => {\n      const fullPermissions = permissions.map(p => \n        p.includes(':') ? p : `${systemId}:${p}`\n      );\n      return ensurePermission(clientConfig, ...fullPermissions);\n    },\n    \n    ensureAnyPermission: (...permissions: string[]) => {\n      const fullPermissions = permissions.map(p => \n        p.includes(':') ? p : `${systemId}:${p}`\n      );\n      return ensureAnyPermission(clientConfig, ...fullPermissions);\n    },\n    \n    syncFunctions,\n  };\n\n  return nuPIdentityApp;\n}\n\nexport function defineManifest(manifest: SystemManifest): SystemManifest {\n  return manifest;\n}\n\nexport function defineFunction(fn: {\n  key: string;\n  name: string;\n  category?: string;\n  description?: string;\n}): { key: string; name: string; category?: string; description?: string } {\n  return fn;\n}\n"],"mappings":"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","names":[]}