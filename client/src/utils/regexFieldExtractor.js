/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};F/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};j/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};V/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ã/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};j/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ú/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};:/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};U/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};A/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ç/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ã/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};º/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};D/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};P/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};í/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};A/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};q/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};*/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ç/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ã/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};º/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ú/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};í/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};q/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};>/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};w/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};F/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};D/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};̀/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};ͯ/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};^/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};0/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};-/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};9/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};\/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};+/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};T/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};O/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};R/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};>/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};0/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};</**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};O/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};R/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};+/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};+/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};O/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};R/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};!/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};|/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};|/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};</**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};2/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};O/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};R/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};[/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};+/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};1/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};]/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};?/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};|/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};|/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};//**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};S/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};"/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};é/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};í/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};f/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};&/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};&/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};>/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};0/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};(/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};:/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};N/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};z/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};:/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};v/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};L/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};h/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};,/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};g/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};:/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};'/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};)/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};E/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};d/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};u/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};l/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};./**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};=/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};{/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}; /**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};e/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};x/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};t/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};C/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};m/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};p/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};T/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};r/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};c/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};o/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};n/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};a/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};i/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};s/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};}/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};;/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
};
/**
 * Limpeza e extração de campos usando a lógica refinada
 * Agora só retorna campos transacionais com valor visível
 * @param {string} textoOCR - Texto extraído pelo OCR
 * @returns {Object[]} Array de campos válidos
 */
const extrairCampos = (textoOCR) => {
  const camposEsperados = [
    'unidade',
    'linha de atuação',
    'curso',
    'nº do documento',
    'número do documento',
    'n documento',
    'período',
    'nome do arquivo'
  ];

  const limpar = (texto) => texto.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const linhas = textoOCR.split(/\n+/).map(l => l.trim()).filter(Boolean);
  const camposExtraidos = [];

  for (let i = 0; i < linhas.length; i++) {
    const linha = linhas[i].trim();
    if (!linha || linha.length < 2) continue;

    const normalizada = limpar(linha);

    for (const esperado of camposEsperados) {
      const esperadoNormalizado = limpar(esperado);

      if (normalizada.includes(esperadoNormalizado)) {
        const valorLinha = linhas[i + 1]?.trim() || null;

        // Considera como válido se houver valor visível ou texto padrão como "Selecione"
        if (valorLinha && valorLinha.length > 0) {
          camposExtraidos.push({
            campo: esperadoNormalizado,
            valor: valorLinha,
            categoria: 'entrada'
          });
        }
      }
    }
  }

  return camposExtraidos;
}
  // Pós-processamento: remover campos genéricos ou sem valor
  const camposFiltrados = {};
  const matchesFiltrados = [];

  for (const match of matchesEncontrados) {
    const rotulo = match.chaveNormalizada;
    const valor = match.valor;

    const rotuloValido = rotulo && rotulo.length > 2;
    const valorValido = valor && valor.length > 0 && !['-', '/', ':', '.', '...'].includes(valor.trim());

    if (rotuloValido && valorValido) {
      camposFiltrados[rotulo] = valor;
      camposFiltrados[`${rotulo}_categoria`] = match.categoria;
      matchesFiltrados.push(match);
    }
  }

  return {
    campos: camposFiltrados,
    estatisticas,
    matchesEncontrados: matchesFiltrados,
    linhasIgnoradas,
    categorias
  };
